#!/usr/bin/env python
# coding: utf-8

# ### ИНФО

# Имеется выгрузка с временной статистикой работы асессоров над однотипным заданием.Задание может состоять из одного или несколько микрозаданий. Время резервирования задания (assigned_ts) указывает на тот момент, когда система назначила определенного асессора исполнителем этого задания. Этот момент может совпадать с временем начала работы асессора над заданием, а может и не совпадать (асессор может отойти выпить чаю, а потом приступить к заданию, асессор может выполнять предыдущее задание, в то время как за ним зарезервированы новые).
# Предположим, что асессор за 30 секунд своего рабочего времени получает N рублей.
# Какую оплату вы считаете справедливой для выполнения асессором одного микрозадания из этого файла? Опишите подробно все этапы вашего решения.
# 
# 
# Формат исходника: 
#  - login — логин асессора
#  - tid — id оцениваемого задания (task id)
#  - Microtasks – количество микрозаданий в одном задании
#  - assigned_ts — время резервирования системой задания для асессора
#  - closed_ts — точное время завершения работы над заданием
#  
#  разделитель — табуляция \t

# ### ИМПОРТ ИНСТРУМЕНТОВ

# In[18]:


#импортируем необходимые библиотеки
import pandas as pd
import numpy as np
import datetime as dt 
from scipy.stats import t
import math


# ### ОЗНАКОМЛЕНИЕ С ДАННЫМИ

# In[19]:


#читаем файл с предустановкой форматов для каждого из столбцов и распознованием дат
dtypes={'login': 'str', 'tid': 'int', 'Microtasks': 'int', 'assigned_ts': 'str', 'closed_ts':'str'}
parse_dates=['assigned_ts','closed_ts']
db=pd.read_csv(r'C:\Users\devba\Documents\DataScience\Vacancies\файл 1.txt',sep='\t', dtype=dtypes, parse_dates=parse_dates)


# In[20]:


#так выглядят записи нашей таблицы
db.sample(10)


# In[5]:


db.info()


# пропусков в данных нет , всего в таблице 701827 строк 

# ### ГЕНЕРАЦИЯ НОВЫХ ДАННЫХ

# In[22]:


#введем новый столбец, показывающий время, затраченное на выполнение каждого задания
db['time_per_task']=(db.closed_ts-db.assigned_ts).dt.seconds


# In[23]:


#введем новый столбец, показывающий время, затраченное на выполнение каждого микрозадания
db['av_time_per_microtask']=np.round(db.time_per_task/db.Microtasks,2)


# In[8]:


db.sample(10)


# В вводной информации было отмечено, что: 
#     1 все задания однотипны 
#     2 время назначения задания асессору и начало его работы над заданием могут не совпадать
# 
# Делаем вывод, что если однотипны задания, то однотипны и микрозадания. Следовательно, в случаях, когда асессор приступил к выполнению задания не сразу длительность выполнения им конкретного задания будет велика в сравнении со средней затратой по времени выполнения однотипных заданий. Вычислить эти отклонения поможет поиск выбросов.

# ### ОЧИСТКА ДАННЫХ

# In[24]:


#функция по отбрасыванию статистических выбросов 
def outliers(column):
    Q1 = column.quantile(0.25)
    Q3 = column.quantile(0.75)
    IQR = Q3-Q1
    l_boundary=Q1-1.5*IQR
    h_boundary=Q3+1.5*IQR
    
    outliers = column[~column.between(l_boundary, h_boundary)]
    n_outl=outliers.count()
    p_outl=np.round(n_outl*100/len(db),2)
    print('Minor boundries are ({},{})\n There are {} or {}% outlying values'          .format(l_boundary,h_boundary,n_outl,p_outl))
    
    inp=input('Clear outliers?\n Input Y (for yes) or N (for no): ')
    
    if inp=='Y': 
        if (type(l_boundary)==int)|(type(l_boundary)==np.float64):
            column=column[column.between(l_boundary, h_boundary)]
        else: 
            column=column[column.between(str(l_boundary), str(h_boundary))]
    else: 
        column=column
    
    return column


# In[13]:


cleaned_db=outliers(db['av_time_per_microtask']).describe()
cleaned_db


# ### АНАЛИЗ И УМОЗАКЛЮЧЕНИЕ

# Доля выбросов в общей таблице сравнительно невелика: 13,45%, поэтому от них можно избавиться  для получения данных больше соответствующих реальности. На основании уже очищенных данных мы можем посчитать доверительный интервал затрат по времени на выполнение одного микрозадания с точностью 99%. 

# In[25]:


def confidence_interval_t(alpha, s, n, mean):
    value = -t.ppf(alpha / 2, n - 1) * s / math.sqrt(n)
    return mean - value, mean + value


# In[26]:


alpha=0.005
s=cleaned_db[2]
n=cleaned_db[0]
mean=cleaned_db[5]
confidence_interval_t(alpha, s, n, mean)


# Полученный результат указывает на то, что в 99% случаев на выполнение одного микрозадания в среднем сазтрачивается от 61,70 до 62,29 секунд. Нам известно, что за 30 секунд рабочего времени асессор получает N руб. Делим средние затраты на одно микрозадание на 30 секунд.

# In[201]:


l_b=61.71/30
h_b=62.29/30
print(round(l_b,2), round(h_b,2))


# Получается, что справедливая оплата за выполнение одного микрозадания должна лежать в интервале [2,06N, 2,08N] руб.
